**К ссылочным типам относятся:**

- class
- interface
- delegate
- object
- string

**Значимые типы:**
- Структуры (struct)
- Перечисления (enum)

-------------------------

- Рекомендации Microsoft по выбору class/struct: https://docs.microsoft.com/ru-ru/dotnet/standard/design-guidelines/choosing-between-class-and-struct
1) Выделение и освобождение типов значений являются общими дешевле, чем выделение и освобождение ссылочных типов.
2) Типы значений упаковываются при приведении к ссылочному типу или к одному из интерфейсов, которые они реализуют. Они будут распакованы при приведении обратно к типу значения. Так как поля представляют собой объекты, выделенные в куче и собираемые сборщиком мусора, слишком много упаковки и распаковки могут негативно повлиять на кучу, сборщик мусора и в конечном итоге производительность приложения. В отличие от этого, такая упаковка не происходит, так как ссылочные типы являются приведенными
3) Присваивания больших ссылочных типов дешевле, чем присваивания типов больших значений.
4) Изменения в экземпляр ссылочного типа влияют на все ссылки, указывающие на экземпляр. Экземпляры типа значения копируются, когда они передаются по значению. При изменении экземпляра типа значения это само по себе не влияет на его копии. Поскольку копии не создаются явным образом пользователем, но неявно создаются при передаче аргументов или возвращении возвращаемых значений, типы значений, которые могут быть изменены, могут вызвать путаницу для многих пользователей. Поэтому типы значений должны быть неизменяемыми.

-------------------------

- **Сборщик мусора** управляет выделением и освобождением памяти для приложения. В среде CLR сборщик мусора выполняет функции автоматического диспетчера памяти. 
- **Стек** - это структура данных, организованная по принципу LIFO (последний вошел - первый вышел). Если вдуматься, это идеальное решение для хранения данных, к которым вскоре предстоит обратиться (легко извлекаются с вершины стека). Де-факто природа области стека заключается в двух постулатах: "помнить" порядок выполнения и хранить значимые типы данных.
- **Куча** схож со стеком, но если стек представляется в виде последовательности коробок, складируемых друг на друге, в случае с кучей эти самые коробки аккуратно разложены и мы можем получить к ним доступ в любое время.
- Основное различие между ссылочными и значимыми типами данных заключается в том, что ссылочные типы данных передаются по адресу – то есть при передаче ссылочной переменной в виде параметра метода передается всего лишь общий адрес на ячейку памяти с данными объекта. В случае же со значимыми типами данных, между методами передается копия самого объекта.

-------------------------
 - С помощью оператора new в куче для хранения объекта CLR выделяет участок памяти. А в стек добавляет адрес на этот участок памяти.
 
- Так же надо отметить, что для крупных объектов существует своя куча - Large Object Heap. В эту кучу помещаются объекты, размер которых больше 85 000 байт. Особенность этой кучи состоит в том, что при сборке мусора сжатие памяти не проводится по причине больших издержек, связанных с размером объектов.

- Кроме того, чтобы снизить издержки от работы сборщика мусора, все объекты в куче разделяются по поколениям.
Всего существует три поколения объектов: 0, 1 и 2-е:

- **Поколение 0.** Идентифицируется новый только что размещённый объект, который ещё никогда не помечался как надлежащий удалению в процессе сборки мусора. Это самое молодое поколение содержит короткоживущие объекты. Примером короткоживущего объекта является временная переменная. Сборка мусора чаще всего выполняется в этом поколении.

- **Поколение 1.** Идентифицирует объект, который уже «пережил» один процесс сборки мусора (был помечен, как надлежащий удалению, но не был удалён из-за достаточного свободного места в куче). Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

- **Поколение 2.** Идентифицирует объект, который пережил более одного прогона сбора мусора. Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

-------------------------
- Управляемая память в .Net поделена на стек и несколько хипов. Самые важные из хипов – это обычная (эфемерная) куча и LOH. Эфемерная куча – это то место, где живут все обычные объекты. LOH – это то место где живут большие (больше 85000 байт) объекты.
- LOH обладает некоторыми особенностями:
1) Объекты в LOH никогда не перемещаются
2) LOH только растет и никогда не уменьшается (т.е. если объект собран сборщиком мусора, размер LOH все равно остается неизменным)
3) Хип LOH освобождается только тогда, когда LOH полностью пуст

-------------------------

- Dispose (IDisposable) - механизм для освобождения неуправляемых ресурсов. Служит для указания того, что класс содержит обязательные для освобождения ресурсы и что его можно (и нужно) использовать в конструкции
- Finalize (Object) - перегрузка метода Finalize класса System.Object, которая создаётся компилятором в случае, когда в классе объявляется собственный деструктор. Позволяет объекту попытаться освободить ресурсы и выполнить другие операции по очистке перед тем, как объект будет утилизирован сборщиком мусора
- CancellationToken - являются частью механизма отмены асинхронных операций. Чтобы отменить задачу нужно вызвать метод Cancel у экземпляра CancellationTokenSource. Он переведет все выпущенные токены в отмененное состояние. Внутри асинхронного метода сработает проверка токена и работа будет завершена. Также CancellationTokenSource позволяет установить таймаут по истечению которого автоматически отменяться все токены.


-------------------------

- Метод **GetHashCode** позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты.
- **Equals** compares **values**
- **==** compares object **references**
- **==** и **RefefenceEquals** работает идентично, сравнивая ссылки на объекты в heap'е
- При реализации типа значения рекомендуется переопределить метод Equals. При этом обеспечивается повышенная производительность по сравнению с реализацией метода Equals по умолчанию для ValueType.
- При реализации ссылочного типа рекомендуется переопределить метод Equals, если ваш тип выглядит как базовый, например Point, String, BigNumber и т. д.
- Переопределите метод GetHashCode, чтобы тип правильно работал в хэш-таблице.

-------------------------

**Жизненный цикл сервиса определяют следующие три метода:**

- **AddTransient**
Transient подразумевает, что сервис создается каждый раз, когда его запрашивают. Этот жизненный цикл лучше всего подходит для легковесных, не фиксирующих состояние, сервисов.

- **AddScoped**
Scoped - сервис создаются единожды для каждого запроса.

- **AddSingleton**
Singleton - сервис создается при первом запросе (или при запуске ConfigureServices, если вы указываете инстанс там), а затем каждый последующий запрос будет использовать этот же инстанс.

-------------------------

**Потокобезопасные коллекции:**
- **BlockingCollection<T>** - Предоставляет возможности блокировки и ограничения для потокобезопасных коллекций, реализующих IProducerConsumerCollection<T>.
- **ConcurrentBag<T>** - Представляет потокобезопасную неупорядоченную коллекцию объектов.
- **ConcurrentDictionary<TKey,TValue>**	- Представляет потокобезопасную коллекцию пар "ключ-значение", доступ к которой могут одновременно получать несколько потоков.
- **ConcurrentQueue<T>** - Предоставляет потокобезопасную коллекцию, обслуживаемую по принципу «первым поступил — первым обслужен» (FIFO).
- **ConcurrentStack<T>** - Предоставляет потокобезопасную коллекцию, обслуживаемую по принципу «последним поступил — первым обслужен» (LIFO).
- **OrderablePartitioner<TSource>**	- Представляет определенный способ разделения упорядочиваемого источника данных на несколько разделов.
- **Partitioner** - Предоставляет общие стратегии создания разделов в массивах, списках и перечисляемых коллекциях.
- **Partitioner<TSource>** - представляет определенный способ разделения источника данных на несколько разделов.
-------------------------
**Monitor vs Lock:**
- Monitor is no different from lock but the monitor class provides more control over the synchronization of various threads trying to access the same lock of code.

```
Monitor.Enter 
Monitor.TryEnter
Monitor.Exit
Monitor.Wait
Monitor.Pulse
Monitor.PulseAll
```
-------------------------

- **ReaderWriterLockSlim** - помогает избегать потенциальных дедлоков. Общая рекомендация - использовать его.
- **ManualResetEventSlim** - лучшая производительность, когда время ожидания - очень короткое, без межпроцессорного взаимодействия  
- **SemaphoreSlim** - упрощенный быстрый, когда время ожидания - очень короткое, без межпроцессорного взаимодействия. Это упрощенная альтернатива Semaphore, которую можно использовать для синхронизации в рамках одного процесса. SemaphoreSlim Класс представляет упрощенный, быстрый семафор, который можно использовать для ожидания внутри одного процесса, когда предполагается, что времена ожидания будут очень короткими.
- **ManualResetEventSlim** - этот класс можно использовать для лучшей производительности, чем ManualResetEvent когда ожидается очень короткое время ожидания и когда событие не пересекает границу процесса.

- One difference is that SemaphoreSlim does not permit named semaphores, which can be system-wide. This would mean that a SemaphoreSlim could not be used for cross-process synchronization.
- The SemaphoreSlim class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.
- ReaderWriterLockSlim is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state. ReaderWriterLockSlim avoids many cases of potential deadlock. In addition, the performance of ReaderWriterLockSlim is significantly better than ReaderWriterLock. ReaderWriterLockSlim is recommended for all new development.

- ReaderWriterLockSlim is not thread-abort safe. You should not use it in an environment where threads accessing it can be aborted, such as .NET Framework. If you're using .NET Core or .NET 5+, it should be fine. Abort is not supported in .NET Core and is obsolete in .NET 5 and later versions.

-------------------------

- System.Threading.SynchronizationContext “Обеспечивает базовую функциональность для распространения контекста синхронизации в различных моделях синхронизации”

-------------------------
- ConfigureAwait(continueOnCapturedContext: false) используется для предотвращения принудительного вызова коллбэка в исходном контексте или планировщике. Это дает нам несколько преимуществ:
1) Улучшение производительности. Существуют накладные расходы постановки обратного вызова в очередь, в отличие просто от вызова, так как для этого требуется дополнительная работа (и, как правило, дополнительная аллокация).
2) Предотвращение дедлоков.

- Если вы пишете код уровня приложения, не используйте ConfigureAwait(false)
- Это приводит нас к следующему: если вы пишете код библиотеки общего назначения, используйте ConfigureAwait(false)

- ASP.NET Core does not have a SynchronizationContext. If you are on ASP.NET Core, it does not matter whether you use ConfigureAwait(false) or not. For ASP.NET "Full" or "Classic" or whatever, the rest of this answer still applies.

-------------------------

- TaskScheduler

-------------------------

- Lookup vs Dictionary

------------------------

Ключевое слово yield используется для создания генераторов последовательностей элементов. Эти генераторы не создают коллекции - вместо этого хранится лишь текущее состояние, а по команде производится переход к следующему. Таким образом, объём требуемой памяти оказывается минимальным и напрямую не зависит от количества элементов. Нетрудно догадаться, что генерируемые последовательности могут быть бесконечными.

Итератор по сути представляет блок кода, который использует оператор yield для перебора набора значений. Данный блок кода может представлять тело метода, оператора или блок get в свойствах.
Итератор использует две специальных инструкции:

yield return: определяет возвращаемый элемент

yield break: указывает, что последовательность больше не имеет элементов

```
public IEnumerator GetEnumerator()
{
    for (int i = 0; i < 6; i++)
    {
        yield return i * i;
    }
}
```

-------------------------
**LINQ (Language-Integrated Query)** - представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

Существует несколько **разновидностей LINQ**:

- **LINQ to Objects**: применяется для работы с массивами и коллекциями
- **LINQ to Entities**: используется при обращении к базам данных через технологию Entity Framework
- **LINQ to XML**: применяется при работе с файлами XML
- **LINQ to DataSet**: применяется при работе с объектом DataSet
- **Parallel LINQ (PLINQ)**: используется для выполнения параллельных запросов
--------------------------------------------------------
```
IEnumerable<int> orderingQuery =
    from num in numbers
    where num < 3 || num > 7
    orderby num ascending
    select num;
```

**GroupBy:**
```
string[] groupingQuery = { "carrots", "cabbage", "broccoli", "beans", "barley" };
IEnumerable<IGrouping<char, string>> queryFoodGroups =
    from item in groupingQuery
    group item by item[0];
```

**GroupBy:**
```
var queryCustomersByCity =
      from cust in customers
      group cust by cust.City;
```

**Average/Concat:**
```
List<int> numbers1 = new() { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
List<int> numbers2 = new() { 15, 14, 11, 13, 19, 18, 16, 17, 12, 10 };

// Query #4.
double average = numbers1.Average();

// Query #5.
IEnumerable<int> concatenationQuery = numbers1.Concat(numbers2);
```

**join:**
```
var innerJoinQuery =
    from cust in customers
    join dist in distributors on cust.City equals dist.City
    select new { CustomerName = cust.Name, DistributorName = dist.Name };
```

**let:**
```
string[] names = { "Svetlana Omelchenko", "Claire O'Donnell", "Sven Mortensen", "Cesar Garcia" };
IEnumerable<string> queryFirstNames =
    from name in names
    let firstName = name.Split(' ')[0]
    select firstName;
```

**Subquery:**
```
var queryGroupMax =
    from student in students
    group student by student.Year into studentGroup
    select new
    {
        Level = studentGroup.Key,
        HighestScore = (
            from student2 in studentGroup
            select student2.ExamScores.Average()
        ).Max()
    };
```
--------------------------------------------------------
Список используемых методов расширения LINQ:

**ThenByDescending**: задает дополнительные критерии для упорядочивания элементов по убыванию
**LastOrDefault**: выбирает последний элемент коллекции или возвращает значение по умолчанию
**Select**: определяет проекцию выбранных значений
**Where**: определяет фильтр выборки
**OrderBy**: упорядочивает элементы по возрастанию
**OrderByDescending**: упорядочивает элементы по убыванию
**ThenBy**: задает дополнительные критерии для упорядочивания элементов возрастанию
**Join**: соединяет две коллекции по определенному признаку
**Aggregate**: применяет к элементам последовательности агрегатную функцию, которая сводит их к одному объекту
**GroupBy**: группирует элементы по ключу
**ToLookup**: группирует элементы по ключу, при этом все элементы добавляются в словарь
**GroupJoin**: выполняет одновременно соединение коллекций и группировку элементов по ключу
**Reverse**: располагает элементы в обратном порядке
**All**: определяет, все ли элементы коллекции удовлятворяют определенному условию
**Any**: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию
**Contains**: определяет, содержит ли коллекция определенный элемент
**Distinct**: удаляет дублирующиеся элементы из коллекции
**Except**: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции
**Union**: объединяет две однородные коллекции
**Intersect**: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях
**Count**: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию
**Sum**: подсчитывает сумму числовых значений в коллекции
**Average**: подсчитывает cреднее значение числовых значений в коллекции
**Min**: находит минимальное значение
**Max**: находит максимальное значение
**Take**: выбирает определенное количество элементов
**Skip**: пропускает определенное количество элементов
**TakeWhile**: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно
**SkipWhile**: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы
**Concat**: объединяет две коллекции
**Zip**: объединяет две коллекции в соответствии с определенным условием
**First**: выбирает первый элемент коллекции
**FirstOrDefault**: выбирает первый элемент коллекции или возвращает значение по умолчанию
**Single**: выбирает единственный элемент коллекции, если коллекция содержит больше или меньше одного элемента, то генерируется исключение
**SingleOrDefault**: выбирает единственный элемент коллекции. Если коллекция пуста, возвращает значение по умолчанию. Если в коллекции больше одного элемента, генерирует исключение
**ElementAt**: выбирает элемент последовательности по определенному индексу
**ElementAtOrDefault**: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона
**Last**: выбирает последний элемент коллекции
**LastOrDefault**: выбирает последний элемент коллекции или возвращает значение по умолчанию
--------------------------------------------------------


