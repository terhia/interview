**К ссылочным типам относятся:**

- class
- interface
- delegate
- object
- string

**Значимые типы:**
- Структуры (struct)
- Перечисления (enum)

-------------------------

- **Сборщик мусора** управляет выделением и освобождением памяти для приложения. В среде CLR сборщик мусора выполняет функции автоматического диспетчера памяти. 
- **Стек** - это структура данных, организованная по принципу LIFO (последний вошел - первый вышел). Если вдуматься, это идеальное решение для хранения данных, к которым вскоре предстоит обратиться (легко извлекаются с вершины стека). Де-факто природа области стека заключается в двух постулатах: "помнить" порядок выполнения и хранить значимые типы данных.
- **Куча** схож со стеком, но если стек представляется в виде последовательности коробок, складируемых друг на друге, в случае с кучей эти самые коробки аккуратно разложены и мы можем получить к ним доступ в любое время.
- Основное различие между ссылочными и значимыми типами данных заключается в том, что ссылочные типы данных передаются по адресу – то есть при передаче ссылочной переменной в виде параметра метода передается всего лишь общий адрес на ячейку памяти с данными объекта. В случае же со значимыми типами данных, между методами передается копия самого объекта.

-------------------------
 - С помощью оператора new в куче для хранения объекта CLR выделяет участок памяти. А в стек добавляет адрес на этот участок памяти.
 
- Так же надо отметить, что для крупных объектов существует своя куча - Large Object Heap. В эту кучу помещаются объекты, размер которых больше 85 000 байт. Особенность этой кучи состоит в том, что при сборке мусора сжатие памяти не проводится по причине больших издержек, связанных с размером объектов.

- Кроме того, чтобы снизить издержки от работы сборщика мусора, все объекты в куче разделяются по поколениям.
Всего существует три поколения объектов: 0, 1 и 2-е:

- **Поколение 0.** Идентифицируется новый только что размещённый объект, который ещё никогда не помечался как надлежащий удалению в процессе сборки мусора. Это самое молодое поколение содержит короткоживущие объекты. Примером короткоживущего объекта является временная переменная. Сборка мусора чаще всего выполняется в этом поколении.

- **Поколение 1.** Идентифицирует объект, который уже «пережил» один процесс сборки мусора (был помечен, как надлежащий удалению, но не был удалён из-за достаточного свободного места в куче). Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

- **Поколение 2.** Идентифицирует объект, который пережил более одного прогона сбора мусора. Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

-------------------------

- Dispose (IDisposable) - механизм для освобождения неуправляемых ресурсов. Служит для указания того, что класс содержит обязательные для освобождения ресурсы и что его можно (и нужно) использовать в конструкции
- Finalize (Object) - перегрузка метода Finalize класса System.Object, которая создаётся компилятором в случае, когда в классе объявляется собственный деструктор. Позволяет объекту попытаться освободить ресурсы и выполнить другие операции по очистке перед тем, как объект будет утилизирован сборщиком мусора
- CancellationToken - являются частью механизма отмены асинхронных операций. Чтобы отменить задачу нужно вызвать метод Cancel у экземпляра CancellationTokenSource. Он переведет все выпущенные токены в отмененное состояние. Внутри асинхронного метода сработает проверка токена и работа будет завершена. Также CancellationTokenSource позволяет установить таймаут по истечению которого автоматически отменяться все токены.


-------------------------

- Метод **GetHashCode** позволяет возвратить некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу, например, можно сравнивать объекты.
- **Equals** compares **values**
- **==** compares object **references**
- **==** и **RefefenceEquals** работает идентично, сравнивая ссылки на объекты в heap'е
- При реализации типа значения рекомендуется переопределить метод Equals. При этом обеспечивается повышенная производительность по сравнению с реализацией метода Equals по умолчанию для ValueType.
- При реализации ссылочного типа рекомендуется переопределить метод Equals, если ваш тип выглядит как базовый, например Point, String, BigNumber и т. д.
- Переопределите метод GetHashCode, чтобы тип правильно работал в хэш-таблице.

-------------------------

**Жизненный цикл сервиса определяют следующие три метода:**

- **AddTransient**
Transient подразумевает, что сервис создается каждый раз, когда его запрашивают. Этот жизненный цикл лучше всего подходит для легковесных, не фиксирующих состояние, сервисов.

- **AddScoped**
Scoped - сервис создаются единожды для каждого запроса.

- **AddSingleton**
Singleton - сервис создается при первом запросе (или при запуске ConfigureServices, если вы указываете инстанс там), а затем каждый последующий запрос будет использовать этот же инстанс.
