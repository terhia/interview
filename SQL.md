**ACID**
- atomicity (атомарность) - гарантирует, что никакая транзакция не будет зафиксирована частично. Либо полностью, либо не выполнена совсем
- consistency (согласованность) - после выполнения транзакции БД также будет в согласованном (корректном) состоянии
- isolation (изоляция) - параллельные транзакции не должны влиять на результат
- durability (надёжность, устойчивость) - если случится сбой в БД и другие проблемы все выполненные транзакции - будут сохранены

--------------------------------------------

Под **«уровнем изоляции транзакций»** понимается степень обеспечиваемой внутренними механизмами СУБД (то есть не требующей специального программирования) защиты от всех или некоторых вышеперечисленных видов несогласованности данных, возникающих при параллельном выполнении транзакций.

 - **Read uncommitted** (чтение незафиксированных данных) - Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определённое всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
 - **Read committed** (чтение фиксированных данных) - Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle Database, по умолчанию используют именно этот уровень. На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных. 
 - **Repeatable read** (повторяющееся чтение) - Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена. 
 - **Serializable** (упорядочиваемость) - Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга. Результат выполнения нескольких параллельных транзакций должен быть таким, как если бы они выполнялись последовательно. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения». 

--------------------------------------------
- **DDL (Data Definition Language)** - `CREATE`, `ALTER`, `DROP`
- **DML (Data Manipulation Language)** - `SELECT`, `INSERT`, `UPDATE`, `DELETE`
- **TCL (Transaction Control Language)** - `COMMIT`, `ROLLBACK`, `SAVEPOINT`
- **DCL (Data Control Language)** - `GRANT`, `REVOKE`, `DENY`
--------------------------------------------

**Типы соединения таблиц:**

 - INNER JOIN
 - LEFT JOIN
 - RIGHT JOIN
 - FULL JOIN
 - CROSS JOIN
 - SELF JOIN
    
![Types-of-Join-inSQL](https://github.com/terhia/interview/assets/7370741/734bf5c0-1a45-4ef2-84aa-c6500e0ea34f)


--------------------------------------------
*Типы констрейнтов:*
- Check constraint
- Default constraint
- Foreign key
- Primary key
- Unique clustered index
- Unique constraint
- Unique index
--------------
- **Нормальная форма** - свойство отношения, характеризующее его с точки зрения избыточности.
- **Нормализация** - процесс минимизации избыточности отношения (приведение к НФ).

- **1-ая нормальная форма:**
1) Нет строк-дубликатов
2) Все атрибуты простых типов данных
3) Все значения - скалярные

- **2-ая нормальная форма:**
1) Удовлетворяет 1-ой НФ
2) Есть первичный ключ
3) Все атрибуты (поля) описывают первичный ключ целиком, а не лишь его частью

- **3-ья нормальная форма:**
1) Удовлетворяет 2-ой НФ
2) Нет зависимостей одних неключевых атрибутов от других (все атрибуты зависят только от первичных ключей)
--------------
- **View (Представление)** - сохраненный запрос в виде объекта БД (виртуальная таблица)
- Типы представлений:
1) Временные
2) Рекурсивные
3) Обновляемые
4) Материализуемые

--------------------------------------------
Common Table Expressions (CTE) или обобщенное табличное выражение - позволяют разбить сложный запрос T-SQL на несколько запросов, что придаёт больше гибкости и управляемости. CTE во многом очень похожи на представления. В отличие от представления, которое можно создать один раз и потом использовать в других запросах, CTE привязан только к одному запросу

Пример
```
WITH cte AS
(
  SELECT id FROM salary
)
SELECT * FROM cte ORDER BY id
```

--------------------------------------------

- **Функции** - объект БД, принимающий аргументы и возвращающий результат.
- Функции (хранимые процедуры) - компилируемы и хранятся на стороне БД, вызов стоит дешево.
- Могут содержать SELECT, INSERT, UPDATE, DELETE (CRUD)
- НЕ могут содержать COMMIT, SAVEPOINT, VACUUM.

--------------------------------------------

- Индексы создаются для столбцов таблиц и представлений. Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными, используя значения первичного ключа, то SQL Server сначала найдет значение индекса, а затем использует индекс для быстрого нахождения всей строки с данными. Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.
- Вы можете создать индекс на большинстве столбцов таблицы или представления. Исключением, преимущественно, являются столбцы с типами данных для хранения больших объектов (LOB), таких как image, text или varchar(max). Вы также можете создать индексы на столбцах, предназначенных для хранения данных в формате XML, но эти индексы устроены немного иначе, чем стандартные и их рассмотрение выходит за рамки данной статьи.
- Индекс состоит из набора страниц, узлов индекса, которые организованы в виде древовидной структуры — сбалансированного дерева. 
- Кластеризованный индекс хранит реальные строки данных в листьях индекса. Возвращаясь к предыдущему примеру, это означает что строка данных, связанная со значение ключа, равного 123 будет храниться в самом индексе. Важной характеристикой кластеризованного индекса является то, что все значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица или представление может иметь только один кластеризованный индекс.
- Таблица не имеющая кластеризованного индекса называется кучей.
- В отличие от кластеризованного индекса, листья некластеризованного индекса содержат только те столбцы (ключевые), по которым определен данный индекс, а также содержит указатель на строки с реальными данными в таблице. Это означает, что системе подзапросов необходима дополнительная операция для обнаружения и получения требуемых данных.
- Некластеризованные индексы не могут быть отсортированы в отличие от кластеризованных, однако вы можете создать более одного некластеризованного индекса на таблице или представлении, вплоть до 999.
- В дополнение к возможности создать несколько некластеризованных индексов, вы можете также включить дополнительные столбцы (included column) в свой индекс: на листьях индекса будет храниться не только значение самих индексированных столбцов, но и значения этих не индексированных дополнительных столбцов.
- В дополнение к тому, что индекс может быть либо кластеризованным, либо некластеризованным, возможно его дополнительно сконфигурировать как составной индекс, уникальный индекс или покрывающий индекс.
- Составной индекс - индекс может содержать более одного столбца. Вы можете включить до 16 столбцов в индекс, но их общая длина ограничена 900 байтами.
- Уникальный индекс - такой индекс обеспечивает уникальность каждого значения в индексируемом столбце.
- Покрывающий индекс- такой индекс позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к записям самой таблицы.
- Насколько полезны индексы могут быть, настолько аккуратно они должны быть спроектированы. Поскольку индексы могут занимать значительное дисковое пространство, вы не захотите создавать индексов больше, чем необходимо. В дополнение, индексы автоматически обновляются когда сама строка с данными обновляется, что может привести к дополнительным накладным расходам ресурсов и падению производительности.
- Наилучшим образом будет применение кластеризованного индекса на столбцах с уникальными значениями и не позволяющими использовать NULL.
- Уникальность значений в столбце влияет на производительность индекса. В общем случае, чем больше у вас дубликатов в столбце, тем хуже работает индекс. С другой стороны, чем больше уникальных значения, тем выше работоспособность индекса. Когда возможно используйте уникальный индекс.
- Для составного индекса возьмите во внимание порядок столбцов в индексе. Столбцы, которые используются в выражениях WHERE (к примеру, WHERE FirstName = 'Charlie') должны быть в индексе первыми. Последующие столбцы должны быть перечислены с учетом уникальности их значений (столбцы с самым высоким количеством уникальных значений идут первыми).
- Кластеризованный индекс – это и есть таблица. Когда вы создаете кластеризованный индекс у таблицы, подсистема хранения данных сортирует все строки в таблице в порядке возрастания или убывания, согласно определению индекса. Кластеризованный индекс это не отдельная сущность как другие индексы, а механизм сортировки данных в таблице и облегчения быстрого доступа к строкам с данными.
- Но в некоторых случаях вы возможно захотите оставить таблицы в их естественном первозданном состоянии, т.е. в виде кучи, и создать лишь некластеризованные индексы для поддержания работоспособности ваших запросов. К примеру, таблица, хранящая лог, преимущественно используется для вставки значений до тех пор пока не будет архивирована. В куче вы не увидите разбиением страниц и фрагментацию данных, как это случается с кластеризованным индексом, потому что строки просто добавляются в конец кучи. Слишком большое разделение страниц может иметь значительное влияние на производительность и в не самом хорошем смысле. В общем, куча позволяет производить вставку данных относительно безболезненно и вам не надо будет бороться с накладными расходами на хранение и обслуживание, как это бывает в случае кластеризованного индекса.
- **Коэффициент заполнения индекса (FILLFACTOR)** определяет количество пространства на странице для хранения индекса на нижнем уровне (уровень листьев) перед тем как начать заполнять новую страницу.
- Можно ли создать кластеризованный индекс на столбце, содержащем дубликаты? И да, и нет. Да вы можете создать кластеризованный индекс на ключевом столбце, содержащем дубликаты значений. Нет, значение ключевого столбца не смогут остаться в состоянии не уникальности. Позвольте объяснить. Если вы создаёте неуникальный кластерный индекс (non-unique clustered index) на столбце, то подсистема хранения данных добавляет к дублирующему значению целочисленное значение (uniquifier), чтобы удостовериться в уникальности и, соответственно, обеспечить возможность идентифицировать каждую строку в кластеризованной таблице. Но значение ключевого столбца обязательно должны быть уникальны, поэтому подсистема хранения данных изменит значение дубликатов таким образом, что они будут выглядеть примерно так: Adams, Franklin, Hancock, Hancock1234, Washington, Smith, Smith4567 и Smith5678.
- SQL Server поддерживает два типа таблиц: кластеризованные таблицы, имеющие кластеризованный индекс и таблицы-кучи или просто кучи.
- Какая взаимосвязь между ограничениями на уникальность значения и первичным ключом с индексами таблицы? Первичный ключ и и ограничение уникальности обеспечивают, что значения в столбце будут уникальны. Вы можете создать только один первичный ключ у таблицы и он не может содержать значения NULL. Вы можете создать у таблицы несколько ограничений на уникальность значения и каждый из них может иметь единственную запись с NULL.
- Обязательно ли создавать кластеризованный индекс на столбце с первичным ключом? Вы можете создать кластеризованный индекс на любой столбце, соответствующем необходимым условиям. Это верно, что кластеризованный индекс и ограничение первичного ключа созданы друг для друга и их брак заключен на небесах, так что усвойте факт, что когда вы создаете первичный ключ, тогда же будет автоматически создан кластеризованный индекс, если он не был создан ранее. Тем не менее, вы можете решить, что кластеризованный индекс будет лучше работать в другом месте, и часто ваше решение будет вполне оправданным.
- Когда вы создаете кластеризованный или некластеризованный индекс у предастваления, то данные физически сохраняются на диск, аналогично обычному индексу. В дополнение, когда в нижележащих таблицах изменяются данные, то индекс представления автоматически изменяется (это означает, что вы можете захотеть избежать индексирования представлений тех таблиц, в которых происходят частые изменения). В любом случае, представление остается представлением — взглядом на таблицы, но именно выполненном в данный момент, с индексами ему соответствующими. Перед тем как вы сможете создать индекс у представления, оно должно соответствовать нескольким ограничениям. К примеру, представление может ссылаться только на базовые таблицы, но не другие представления и эти таблицы должны находиться в той же самой базе данных.
- Коэффициент уникальности значений ключевого столбца называется избирательностью индекса.
- Внешний ключ необязательно должен соответствовать первичному ключу из главной таблицы. Хотя, как правило, внешний ключ из зависимой таблицы указывает на первичный ключ из главной таблицы.
