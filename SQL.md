**ACID**
- atomicity (атомарность) - гарантирует, что никакая транзакция не будет зафиксирована частично. Либо полностью, либо не выполнена совсем
- consistency (согласованность) - после выполнения транзакции БД также будет в согласованном (корректном) состоянии
- isolation (изоляция) - параллельные транзакции не должны влиять на результат
- durability (надёжность, устойчивость) - если случится сбой в БД и другие проблемы все выполненные транзакции - будут сохранены

--------------------------------------------

Под **«уровнем изоляции транзакций»** понимается степень обеспечиваемой внутренними механизмами СУБД (то есть не требующей специального программирования) защиты от всех или некоторых вышеперечисленных видов несогласованности данных, возникающих при параллельном выполнении транзакций.

 - **Read uncommitted** (чтение незафиксированных данных) - Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определённое всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
 - **Read committed** (чтение фиксированных данных) - Большинство промышленных СУБД, в частности, Microsoft SQL Server, PostgreSQL и Oracle Database, по умолчанию используют именно этот уровень. На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных. 
 - **Repeatable read** (повторяющееся чтение) - Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена. 
 - **Serializable** (упорядочиваемость) - Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга. Результат выполнения нескольких параллельных транзакций должен быть таким, как если бы они выполнялись последовательно. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения». 

--------------------------------------------
- **DDL (Data Definition Language)** - `CREATE`, `ALTER`, `DROP`
- **DML (Data Manipulation Language)** - `SELECT`, `INSERT`, `UPDATE`, `DELETE`
- **TCL (Transaction Control Language)** - `COMMIT`, `ROLLBACK`, `SAVEPOINT`
- **DCL (Data Control Language)** - `GRANT`, `REVOKE`, `DENY`
--------------------------------------------

**Типы соединения таблиц:**

 - INNER JOIN
 - LEFT JOIN
 - RIGHT JOIN
 - FULL JOIN
 - CROSS JOIN
 - SELF JOIN
    
![Types-of-Join-inSQL](https://github.com/terhia/interview/assets/7370741/734bf5c0-1a45-4ef2-84aa-c6500e0ea34f)


--------------------------------------------
*Типы констрейнтов:*
- Check constraint
- Default constraint
- Foreign key
- Primary key
- Unique clustered index
- Unique constraint
- Unique index
--------------
- **Нормальная форма** - свойство отношения, характеризующее его с точки зрения избыточности.
- **Нормализация** - процесс минимизации избыточности отношения (приведение к НФ).

- **1-ая нормальная форма:**
1) Нет строк-дубликатов
2) Все атрибуты простых типов данных
3) Все значения - скалярные

- **2-ая нормальная форма:**
1) Удовлетворяет 1-ой НФ
2) Есть первичный ключ
3) Все атрибуты (поля) описывают первичный ключ целиком, а не лишь его частью

- **3-ья нормальная форма:**
1) Удовлетворяет 2-ой НФ
2) Нет зависимостей одних неключевых атрибутов от других (все атрибуты зависят только от первичных ключей)
--------------
- **View (Представление)** - сохраненный запрос в виде объекта БД (виртуальная таблица)
- Типы представлений:
1) Временные
2) Рекурсивные
3) Обновляемые
4) Материализуемые

--------------------------------------------
Common Table Expressions (CTE) или обобщенное табличное выражение - позволяют разбить сложный запрос T-SQL на несколько запросов, что придаёт больше гибкости и управляемости. CTE во многом очень похожи на представления. В отличие от представления, которое можно создать один раз и потом использовать в других запросах, CTE привязан только к одному запросу

Пример
```
WITH cte AS
(
  SELECT id FROM salary
)
SELECT * FROM cte ORDER BY id
```

--------------------------------------------

- **Функции** - объект БД, принимающий аргументы и возвращающий результат.
- Функции (хранимые процедуры) - компилируемы и хранятся на стороне БД, вызов стоит дешево.
- Могут содержать SELECT, INSERT, UPDATE, DELETE (CRUD)
- НЕ могут содержать COMMIT, SAVEPOINT, VACUUM.

--------------------------------------------
- **Коэффициент заполнения индекса (FILLFACTOR)** определяет количество пространства на странице для хранения индекса на нижнем уровне (уровень листьев) перед тем как начать заполнять новую страницу.
Кластеризованные и некластеризованные индексы

Также существуют кластеризованные и некластеризованные индексы. Рассмотрим их более подробно на примере СУБД PostgreSQL 15 версии.

**Кластеризованный индекс** — индекс, который сортирует строки с данными в таблице. Кластеризованный индекс хранит данные в листьях индекса. Главная особенность кластеризованного индекса заключается в том, что все значения отсортированы в определенном порядке либо по возрастанию, либо по убыванию. Следует отметить, что данные в таблице хранятся в отсортированном виде только в том случае, когда у этой таблицы создан кластеризованный индекс. При использовании кластерного индекса данные упорядочены физически (т.е. хранятся, например, на жестком диске). Благодаря этому существенно возрастает скорость поиска данных (при условии последовательного доступа к данным). Однако операция, связанная с изменением порядка данных, может быть затратной и требовать перестроения. В отличие от обычных индексов, кластеризованный индекс создается на всю таблицу сразу, а не на один или более столбцов. В таблице может присутствовать только один кластеризованный индекс.

**Некластеризованный индекс** — индекс, который используется для применения индексов к неключевым столбцам. Главное отличие от кластеризованного индекса заключается в том, что некластеризованный индекс не упорядочивает данные физически. Некластеризованный индекс хранит данные и индексы в разных местах. Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определен данный индекс. Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных. Некластеризованные индексы нельзя отсортировать, в отличие от кластеризованных, однако существует возможность создания более одного некластеризованного индекса. Также при использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.

Типы индексов
 - Уникальный (Unique index) — все значения встречаются только один раз. Если в столбец с уникальным индексом попробовать добавить неуникальное значение, то возникнет ошибка.
 - Неуникальный (Non-unique index) — индекс, при котором значения могут повторяться.
 - Простой (Simple index) — индекс, состоящий из одного поля.
 - Составной (Composite Index) — индекс, который строится по нескольким столбцам таблицы. В данном типе индекса расположение полей является важным.
 - Древовидный (B-tree index) — индекс, который представлен в виде корневой вершины и узлов.
 - Частичный (Partial Indexes) — индекс, который состоит из подмножеств строк таблицы по определенному выражению
